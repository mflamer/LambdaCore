Lambda Core
==
The LambdaCore is a processor based on the Zinc Abstract Machine which was the original execution model for the CAML language. There is an excellent paper describing the ZAM at http://www.enseignement.polytechnique.fr/profs/informatique/Benjamin.Werner/INF565/ZINC.pdf. The idea is to create a small, fast and efficent processor for strict evaluation of functional languages like ML, LISP, etc. Basicly, I dont see why embedded systems must be limited to C or FORTH for software development. The instruction set is about 80% done and a simulator is running. The next step is to finsh the definition of the last few instructions and start on the verilog. 

Word Size: 32bit
Address Size: 16bit word aligned = 64k * 32bit = 256KB


Repo Contents:
LamCor - Simple compiler for a basic S expression based language. Similar to Scheme or Lisp. Written in Haskell.
Simulator - VS2012 solution (C++) for the simulator. Could probably build under GCC without too much trouble.
verilog - Branch of James Bowman's J1 processor I was going to use as the starting point. Nothing done here yet.
InstructionSet.xls - Excel file with the details of the ISA and a diagram of the processor execution model. 

The following is a sample of the simple language compiled by LamCor, this is also in the file LamCor\src\lam.src

(def cntdn 
    (lam x (if x
            (cntdn (- x 1))
            (x))))

(def plus5
    (+ 5))

(def double
    (lam x (+ x x)))

(def half
    (lam x (/> x 1)))
                  

(+ (cntdn (double (plus5 2))) 69)

and, the instructions generated by the compiler (run lamcor.exe in the same folder as a source file named lam.src) then dissasemble using
the simulator (Simulator.exe lam.bin d). The "d" flag is for dissassembly, replace with an "s" for simulation. There are a few simple optimizations I plan to implement soon that will combine any ACC or LDI followed by a PUSH into a single instruction, reducing this by another 6 instructions.

================= RAM Dissassembly ================ 
0: 	LDI 69
1: 	PUSH 
2: 	MARK 
3: 	MARK 
4: 	MARK 
5: 	LDI 2
6: 	PUSH 
7: 	CLOS 27
8: 	APP 
9: 	PUSH 
10: 	CLOS 22
11: 	APP 
12: 	PUSH 
13: 	CLOS 32
14: 	APP 
15: 	ADD 
16: 	END 
17: 	LDI 1
18: 	PUSH 
19: 	ACC 0
20: 	ASHR 
21: 	RETC 
22: 	ACC 0
23: 	PUSH 
24: 	ACC 0
25: 	ADD 
26: 	RETC 
27: 	ACC 0
28: 	PUSH 
29: 	LDI 5
30: 	ADD 
31: 	RETC 
32: 	ACC 0
33: 	IF 36
34: 	ACC 0
35: 	RETC 
36: 	LDI 1
37: 	PUSH 
38: 	ACC 0
39: 	SUB 
40: 	PUSH 
41: 	CLOS 32
42: 	APPT 


When the simulator is run (Simulator.exe lam.bin s) the state of each register is displayed after each instruction is executed.

C:\Users\mflamer\Dropbox\LambdaCore\LamCor\src>Simulator.exe lam.bin s
Loaded 43 instructions... 
A = 0 	 argS = 0 	 retS = 0 	 [E] = 0 
argTOS = 255 	 retTOS = 255 	 E = 48 

0: 	LDI 69
A = 45 	 argS = 0 	 retS = 0 	 [E] = 0 
argTOS = 255 	 retTOS = 255 	 E = 48 

1: 	PUSH 
A = 45 	 argS = 45 	 retS = 0 	 [E] = 0 
argTOS = 0 	 retTOS = 31 	 E = 48 

2: 	MARK 
A = 80000000 	 argS = 80000000 	 retS = 0 	 [E] = 0 
argTOS = 1 	 retTOS = 31 	 E = 48 


This simple language is only intended to be used for testing and eventually to bootstrap other languages. I'm currently considering hosting OCAML byte code and or Shen, as these fit the execution model nicely, would be relativly easy to get running and might actually get used. 