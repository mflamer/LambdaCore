<<<<<<< HEAD
Lambda Core
==
The LambdaCore is a processor based on the Zinc Abstract Machine which was the original execution model for the CAML language. There is an excellent paper describing the ZAM at http://www.enseignement.polytechnique.fr/profs/informatique/Benjamin.Werner/INF565/ZINC.pdf. The idea is to create a small, fast and efficent processor for strict evaluation of functional languages like ML, LISP, etc. Basicly, I dont see why embedded systems must be limited to C or FORTH for software development. The instruction set is about 80% done and a simulator is running. The next step is to finsh the definition of the last few instructions and start on the verilog. 

Word Size: 32bit

Address Size: 16bit word aligned = 64k * 32bit = 256KB


**Repo Contents:**
**LamCor** - Simple compiler for a basic S expression based language. Similar to Scheme or Lisp. Written in Haskell.<br>
**Simulator** - VS2012 solution (C++) for the simulator. Could probably build under GCC without too much trouble.<br>
**verilog** - Branch of James Bowman's J1 processor I was going to use as the starting point. Nothing done here yet.<br>
**InstructionSet.xls** - Excel file with the details of the ISA and a diagram of the processor execution model. <br>
><br>

The following is a sample of the simple language compiled by LamCor, this is also in the file LamCor\src\lam.src

(def cntdn 
    (lam x (if x
            (cntdn (- x 1))
            (x))))

(def plus5
    (+ 5))

(def double
    (lam x (+ x x)))

(def half
    (lam x (/> x 1)))
                  

(+ (cntdn (double (plus5 2))) 69)

and, the instructions generated by the compiler (run lamcor.exe in the same folder as a source file named lam.src) then dissasemble using
the simulator (Simulator.exe lam.bin d). The "d" flag is for dissassembly, replace with an "s" for simulation. There are a few simple optimizations I plan to implement soon that will combine any ACC or LDI followed by a PUSH into a single instruction, reducing this by another 6 instructions.

================= RAM Disassembly ================ <br>
0: 	LDI 69<br>
1: 	PUSH<br> 
2: 	MARK<br> 
3: 	MARK<br> 
4: 	MARK<br> 
5: 	LDI 2<br>
6: 	PUSH<br> 
7: 	CLOS 27<br>
8: 	APP <br>
9: 	PUSH <br>
10: 	CLOS 22<br>
11: 	APP <br>
12: 	PUSH <br>
13: 	CLOS 32<br>
14: 	APP <br>
15: 	ADD <br>
16: 	END <br>
17: 	LDI 1<br>
18: 	PUSH <br>
19: 	ACC 0<br>
20: 	ASHR <br>
21: 	RETC <br>
22: 	ACC 0<br>
23: 	PUSH <br>
24: 	ACC 0<br>
25: 	ADD <br>
26: 	RETC <br>
27: 	ACC 0<br>
28: 	PUSH <br>
29: 	LDI 5<br>
30: 	ADD <br>
31: 	RETC <br>
32: 	ACC 0<br>
33: 	IF 36<br>
34: 	ACC 0<br>
35: 	RETC <br>
36: 	LDI 1<br>
37: 	PUSH <br>
38: 	ACC 0<br>
39: 	SUB <br>
40: 	PUSH <br>
41: 	CLOS 32<br>
42: 	APPT <br>


When the simulator is run (Simulator.exe lam.bin s) the state of each register is displayed after each instruction is executed.

C:\Users\mflamer\Dropbox\LambdaCore\LamCor\src>Simulator.exe lam.bin s
Loaded 43 instructions... 
A = 0 	 argS = 0 	 retS = 0 	 [E] = 0 
argTOS = 255 	 retTOS = 255 	 E = 48 

0: 	LDI 69<br>
A = 45 	 argS = 0 	 retS = 0 	 [E] = 0 
argTOS = 255 	 retTOS = 255 	 E = 48 

1: 	PUSH<br> 
A = 45 	 argS = 45 	 retS = 0 	 [E] = 0 
argTOS = 0 	 retTOS = 31 	 E = 48 

2: 	MARK <br>
A = 80000000 	 argS = 80000000 	 retS = 0 	 [E] = 0 
argTOS = 1 	 retTOS = 31 	 E = 48 


This simple language is only intended to be used for testing and eventually to bootstrap other languages. I'm currently considering hosting OCAML byte code and or Shen, as these fit the execution model nicely, would be relativly easy to get running and might actually get used. 
=======
LambdaCore
==========

Small efficient processor for strict evaluation of lambda calculus 
>>>>>>> 66227b848be8faff9309bfadccd4a29c02edb054
